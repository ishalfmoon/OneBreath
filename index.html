<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>COâ‚‚ Table Trainer & One Breath</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #002b44;
    color: #cce7ff;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    position: relative;
    box-sizing: border-box;
    overflow: hidden;
  }
  .sticker {
    position: absolute;
    user-select: none;
    transition: transform 0.4s ease;
    will-change: transform;
    pointer-events: none;
  }
  #contractionList {
    margin-top: 1rem;
    max-height: 120px;
    overflow-y: auto;
    width: 280px;
    background: rgba(20, 40, 60, 0.6);
    padding: 0.5rem 1rem;
    border-radius: 8px;
    font-size: 1rem;
  }
  #recordSummary {
    margin-top: 1rem;
    font-size: 1.1rem;
    color: #a3e4d7;
  }
  #breathDisplay {
    margin-top: 1rem;
    font-size: 1.5rem;
    font-weight: 600;
    min-height: 2rem;
  }
  button {
    font-size: 1.1rem;
    padding: 0.4rem 1rem;
    margin: 0.4rem;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    background-color: #3db7e4;
    color: #002b44;
    transition: background-color 0.3s ease;
  }
  button:disabled {
    background-color: #006494;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background-color: #66c2ff;
  }
</style>
</head>
<body>

<h1>ğŸ‹ One Breath Mode</h1>
<p>ìˆ¨ì„ ì°¸ì•˜ë‹¤ê°€ ë©ˆì¶”ë©´ ìë™ìœ¼ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤. ì»¨íŠ¸ë ‰ì…˜ì´ ì˜¬ ê²½ìš° ë²„íŠ¼ì„ ëˆŒëŸ¬ ê¸°ë¡í•  ìˆ˜ ìˆì–´ìš”.</p>
<button id="startBtn">Start One Breath</button>
<button id="stopBtn" disabled>Stop</button>
<button id="contractBtn" disabled>Contraction</button>
<div id="breathDisplay">Ready</div>
<div id="recordSummary"></div>
<ul id="contractionList"></ul>
<canvas id="breathCanvas" width="300" height="300"></canvas>

<script>
let breathStartTime = 0;
let breathTimer = null;
let contractionTimes = [];
let breathGoal = 0; // 0ì´ë©´ ë¬´ì œí•œ
let progress = 0;
let animationId = null;
let phase = 'ready'; // ready, prep, hold, stopped

const breathDisplay = document.getElementById('breathDisplay');
const recordSummary = document.getElementById('recordSummary');
const contractionList = document.getElementById('contractionList');
const canvas = document.getElementById('breathCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const contractBtn = document.getElementById('contractBtn');

startBtn.addEventListener('click', startPreparation);
stopBtn.addEventListener('click', stopBreathHold);
contractBtn.addEventListener('click', recordContraction);

function startPreparation() {
  if (phase !== 'ready' && phase !== 'stopped') return;
  phase = 'prep';
  breathDisplay.textContent = 'Get Ready... 10';
  contractionTimes = [];
  recordSummary.textContent = '';
  contractionList.innerHTML = '';
  stopBtn.disabled = true;
  contractBtn.disabled = true;
  startBtn.disabled = true;
  
  let prepTime = 10;
  const prepInterval = setInterval(() => {
    prepTime--;
    if (prepTime > 0) {
      breathDisplay.textContent = `Get Ready... ${prepTime}`;
    } else if (prepTime === 0) {
      breathDisplay.textContent = '3...';
    } else if (prepTime === -1) {
      breathDisplay.textContent = '2...';
    } else if (prepTime === -2) {
      breathDisplay.textContent = '1...';
    } else {
      clearInterval(prepInterval);
      startHold();
      return;
    }
    prepTime--;
  }, 1000);
}

function startHold() {
  phase = 'hold';
  breathStartTime = Date.now();
  stopBtn.disabled = false;
  contractBtn.disabled = false;
  startBtn.disabled = true;
  breathDisplay.textContent = 'Holding breath... 0s';
  animateBreath();
}

function animateBreath() {
  if (phase !== 'hold') {
    cancelAnimationFrame(animationId);
    return;
  }
  const elapsed = (Date.now() - breathStartTime) / 1000;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ëª©í‘œì‹œê°„ ì„¤ì • ì˜ˆ: 180ì´ˆ, ë¬´ì œí•œì¸ ê²½ìš° 60ì´ˆ ë‹¨ìœ„ë¡œ í•œë°”í€´ ëŒê²Œ
  const oneCircleDuration = breathGoal > 0 ? breathGoal : 60;
  
  const circlesPassed = Math.floor(elapsed / oneCircleDuration);
  const circleProgress = (elapsed % oneCircleDuration) / oneCircleDuration;

  // ìƒ‰ìƒ ë³€í™”: íŒŒë‘, ë³´ë¼, ë¹¨ê°• ë°˜ë³µ
  const colors = ['#3db7e4', '#a45db4', '#d42f2f'];
  const color = colors[circlesPassed % colors.length];

  ctx.beginPath();
  ctx.arc(150, 150, 120, -Math.PI/2, -Math.PI/2 + circleProgress * 2 * Math.PI);
  ctx.strokeStyle = color;
  ctx.lineWidth = 10;
  ctx.shadowColor = color;
  ctx.shadowBlur = 8;
  ctx.stroke();

  breathDisplay.textContent = `Holding breath... ${Math.floor(elapsed)}s`;
  
  animationId = requestAnimationFrame(animateBreath);
}

function stopBreathHold() {
  if (phase !== 'hold') return;
  phase = 'stopped';
  cancelAnimationFrame(animationId);
  stopBtn.disabled = true;
  contractBtn.disabled = true;
  startBtn.disabled = false;

  const totalSeconds = Math.floor((Date.now() - breathStartTime) / 1000);
  breathDisplay.textContent = `Held for ${totalSeconds}s`;
  
  // ê¸°ë¡ ìš”ì•½
  let summary = `ğŸ•’ Total: ${formatTime(totalSeconds)}<br>`;
  if (contractionTimes.length > 0) {
    summary += 'ğŸŒ€ Contractions: ' + contractionTimes.map(s => formatTime(s)).join(', ');
  } else {
    summary += 'ğŸŒ€ Contractions: None';
  }
  recordSummary.innerHTML = summary;

  // ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
  contractionList.innerHTML = '';

  // ë¡œì»¬ ì €ì¥ - ê¸°ë¡ ì €ì¥
  saveRecord(totalSeconds, contractionTimes);

  // ìŠ¤í‹°ì»¤ í‘œì‹œ
  const emoji = getSeaCreatureEmoji(totalSeconds);
  const size = getEmojiSize(totalSeconds);
  placeSticker(emoji, size);
}

function recordContraction() {
  if (phase !== 'hold') return;
  const now = Date.now();
  const sec = Math.floor((now - breathStartTime) / 1000);
  contractionTimes.push(sec);
  updateContractionList();
}

function updateContractionList() {
  contractionList.innerHTML = '';
  contractionTimes.forEach((sec, i) => {
    const li = document.createElement('li');
    li.textContent = `ğŸŒ€ Contraction ${i+1}: ${formatTime(sec)}`;
    contractionList.appendChild(li);
  });
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2, '0')}`;
}

// ì´ëª¨ì§€ í¬ê¸° ë° ì¢…ë¥˜ ê²°ì • í•¨ìˆ˜ (ê¸°ì¡´ ì½”ë“œ)
function getEmojiSize(durationSeconds) {
  if (durationSeconds >= 240) return 3.2;
  if (durationSeconds >= 180) return 2.8;
  if (durationSeconds >= 120) return 2.4;
  if (durationSeconds >= 90)  return 2.0;
  if (durationSeconds >= 60)  return 1.6;
  return 1.2;
}

function getSeaCreatureEmoji(durationSeconds) {
  if (durationSeconds >= 240) return "ğŸ‹";
  if (durationSeconds >= 180) return "ğŸ¬";
  if (durationSeconds >= 120) return "ğŸŸ";
  if (durationSeconds >= 90)  return "ğŸ ";
  if (durationSeconds >= 60)  return "ğŸš";
  return "ğŸ¦";
}

function placeSticker(emoji, size) {
  const div = document.createElement('div');
  div.className = 'sticker';
  div.textContent = emoji;
  div.style.fontSize = `${size}rem`;
  div.style.left = `${Math.random() * 90 + 5}%`;
  div.style.top = `${Math.random() * 80 + 10}%`;
  document.body.appendChild(div);
}

// ë¡œì»¬ ì €ì¥ ê´€ë ¨ í•¨ìˆ˜ë“¤
function saveRecord(totalSeconds, contractions) {
  const logs = JSON.parse(localStorage.getItem('oneBreathLogs') || '[]');
  logs.push({
    time: totalSeconds,
    contractions: contractions,
    date: new Date().toISOString()
  });
  localStorage.setItem('oneBreathLogs', JSON.stringify(logs));
}
</script>

</body>
</html>
